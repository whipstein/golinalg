package eig

import (
	"fmt"
	"math"
	"testing"

	"github.com/whipstein/golinalg/golapack"
	"github.com/whipstein/golinalg/golapack/gltest"
	"github.com/whipstein/golinalg/golapack/gltest/matgen"
	"github.com/whipstein/golinalg/mat"
	"github.com/whipstein/golinalg/util"
)

// ddrgvx checks the nonsymmetric generalized eigenvalue problem
// expert driver Dggevx.
//
// Dggevx computes the generalized eigenvalues, (optionally) the left
// and/or right eigenvectors, (optionally) computes a balancing
// transformation to improve the conditioning, and (optionally)
// reciprocal condition numbers for the eigenvalues and eigenvectors.
//
// When ddrgvx is called with NSIZE > 0, two types of test matrix pairs
// are generated by the subroutine DLATM6 and test the driver Dggevx.
// The test matrices have the known exact condition numbers for
// eigenvalues. For the condition numbers of the eigenvectors
// corresponding the first and last eigenvalues are also know
// ``exactly'' (see DLATM6).
//
// For each matrix pair, the following tests will be performed and
// compared with the threshold THRESH.
//
// (1) math.Max over all left eigenvalue/-vector pairs (beta/alpha,l) of
//
//    | l**H * (beta A - alpha B) | / ( ulp math.Max( |beta A|, |alpha B| ) )
//
//     where l**H is the conjugate tranpose of l.
//
// (2) math.Max over all right eigenvalue/-vector pairs (beta/alpha,r) of
//
//       | (beta A - alpha B) r | / ( ulp math.Max( |beta A|, |alpha B| ) )
//
// (3) The condition number S(i) of eigenvalues computed by Dggevx
//     differs less than a factor THRESH from the exact S(i) (see
//     DLATM6).
//
// (4) DIF(i) computed by DTGSNA differs less than a factor 10*THRESH
//     from the exact value (for the 1st and 5th vectors only).
//
// Test Matrices
// =============
//
// Two kinds of test matrix pairs
//
//          (A, B) = inverse(YH) * (Da, Db) * inverse(X)
//
// are used in the tests:
//
// 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
//          0   2+a   0    0    0         0   1   0   0   0
//          0    0   3+a   0    0         0   0   1   0   0
//          0    0    0   4+a   0         0   0   0   1   0
//          0    0    0    0   5+a ,      0   0   0   0   1 , and
//
// 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
//          1    1    0    0    0         0   1   0   0   0
//          0    0    1    0    0         0   0   1   0   0
//          0    0    0   1+a  1+b        0   0   0   1   0
//          0    0    0  -1-b  1+a ,      0   0   0   0   1 .
//
// In both cases the same inverse(YH) and inverse(X) are used to compute
// (A, B), giving the exact eigenvectors to (A,B) as (YH, X):
//
// YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
//         0    1   -y    y   -y         0   1   x  -x  -x
//         0    0    1    0    0         0   0   1   0   0
//         0    0    0    1    0         0   0   0   1   0
//         0    0    0    0    1,        0   0   0   0   1 , where
//
// a, b, x and y will have all values independently of each other from
// { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.
func ddrgvx(nsize int, thresh float64, nin *util.Reader, nout int, a, b, ai, bi *mat.Matrix, alphar, alphai, beta *mat.Vector, vl, vr *mat.Matrix, ilo, ihi int, lscale, rscale, s, dtru, dif, diftru, work *mat.Vector, lwork int, iwork []int, liwork int, result *mat.Vector, bwork []bool, t *testing.T) (nerrs, ntestt int, err error) {
	var abnorm, half, one, ratio1, ratio2, ten, thrsh2, tnth, ulp, ulpinv, zero float64
	var _i, i, iptype, iwa, iwb, iwx, iwy, j, linfo, maxwrk, minwrk, n, nmax, nptknt int

	weight := vf(5)

	zero = 0.0
	one = 1.0
	ten = 1.0e+1
	tnth = 1.0e-1
	half = 0.5

	//     Check for errors

	nmax = 5

	if nsize < 0 {
		err = fmt.Errorf("nsize < 0: nsize=%v", nsize)
	} else if thresh < zero {
		err = fmt.Errorf("thresh < zero: thresh=%v", thresh)
	} else if nout <= 0 {
		err = fmt.Errorf("nout <= 0: nout=%v", nout)
	} else if a.Rows < 1 || a.Rows < nmax {
		err = fmt.Errorf("a.Rows < 1 || a.Rows < nmax: a.Rows=%v, nmax=%v", a.Rows, nmax)
	} else if liwork < nmax+6 {
		err = fmt.Errorf("liwork < nmax+6: liwork=%v, nmax=%v", liwork, nmax)
	}

	//     Compute workspace
	//      (Note: Comments in the code beginning "Workspace:" describe the
	//       minimal amount of workspace needed at that point in the code,
	//       as well as the preferred amount for good performance.
	//       NB refers to the optimal block size for the immediately
	//       following subroutine, as returned by ILAENV.)
	minwrk = 1
	if err == nil && lwork >= 1 {
		minwrk = 2*nmax*nmax + 12*nmax + 16
		maxwrk = 6*nmax + nmax*ilaenv(1, "Dgeqrf", []byte{' '}, nmax, 1, nmax, 0)
		maxwrk = max(maxwrk, 2*nmax*nmax+12*nmax+16)
		work.Set(0, float64(maxwrk))
	}

	if lwork < minwrk {
		err = fmt.Errorf("lwork < minwrk: lwork=%v, minwrk=%v", lwork, minwrk)
	}

	if err != nil {
		gltest.Xerbla2("ddrgvx", err)
		return
	}

	n = 5
	ulp = golapack.Dlamch(Precision)
	ulpinv = one / ulp
	thrsh2 = ten * thresh
	nerrs = 0
	nptknt = 0
	ntestt = 0

	//     Parameters used for generating test matrices.
	weight.Set(0, tnth)
	weight.Set(1, half)
	weight.Set(2, one)
	weight.Set(3, one/weight.Get(1))
	weight.Set(4, one/weight.Get(0))

	for iptype = 1; iptype <= 2; iptype++ {
		for iwa = 1; iwa <= 5; iwa++ {
			for iwb = 1; iwb <= 5; iwb++ {
				for iwx = 1; iwx <= 5; iwx++ {
					for iwy = 1; iwy <= 5; iwy++ {
						//                    generated a test matrix pair
						matgen.Dlatm6(iptype, 5, a, b, vr, vl, weight.Get(iwa-1), weight.Get(iwb-1), weight.Get(iwx-1), weight.Get(iwy-1), dtru, diftru)

						//                    Compute eigenvalues/eigenvectors of (A, B).
						//                    Compute eigenvalue/eigenvector condition numbers
						//                    using computed eigenvectors.
						golapack.Dlacpy(Full, n, n, a, ai)
						golapack.Dlacpy(Full, n, n, b, bi)

						if ilo, ihi, _, _, linfo, err = golapack.Dggevx('N', 'V', 'V', 'B', n, ai, bi, alphar, alphai, beta, vl, vr, lscale, rscale, s, dif, work, lwork, &iwork, &bwork); linfo != 0 || err != nil {
							t.Fail()
							result.Set(0, ulpinv)
							fmt.Printf(" ddrgvx: %s returned info=%6d.\n         n=%6d, jtype=%6d)\n", "Dggevx", linfo, n, iptype)
							goto label30
						}

						//                    Compute the norm(A, B)
						golapack.Dlacpy(Full, n, n, ai, work.Matrix(n, opts))
						golapack.Dlacpy(Full, n, n, bi, work.MatrixOff(n*n, n, opts))
						abnorm = golapack.Dlange('F', n, 2*n, work.Matrix(n, opts), work)

						//                    Tests (1) and (2)
						result.Set(0, zero)
						dget52(true, n, a, b, vl, alphar, alphai, beta, work, result)
						if result.Get(1) > thresh {
							t.Fail()
							fmt.Printf(" ddrgvx: %s Eigenvectors from %s incorrectly normalized.\n Bits of error=%10.3f,         n=%6d, jtype=%6d, IWA=%5d, IWB=%5d, IWX=%5d, IWY=%5d\n", "Left", "Dggevx", result.Get(1), n, iptype, iwa, iwb, iwx, iwy)
						}

						result.Set(1, zero)
						dget52(false, n, a, b, vr, alphar, alphai, beta, work, result.Off(1))
						if result.Get(2) > thresh {
							t.Fail()
							fmt.Printf(" ddrgvx: %s Eigenvectors from %s incorrectly normalized.\n Bits of error=%10.3f,         n=%6d, jtype=%6d, IWA=%5d, IWB=%5d, IWX=%5d, IWY=%5d\n", "Right", "Dggevx", result.Get(2), n, iptype, iwa, iwb, iwx, iwy)
						}

						//                    Test (3)
						result.Set(2, zero)
						for i = 1; i <= n; i++ {
							if s.Get(i-1) == zero {
								if dtru.Get(i-1) > abnorm*ulp {
									result.Set(2, ulpinv)
								}
							} else if dtru.Get(i-1) == zero {
								if s.Get(i-1) > abnorm*ulp {
									result.Set(2, ulpinv)
								}
							} else {
								work.Set(i-1, math.Max(math.Abs(dtru.Get(i-1)/s.Get(i-1)), math.Abs(s.Get(i-1)/dtru.Get(i-1))))
								result.Set(2, math.Max(result.Get(2), work.Get(i-1)))
							}
						}

						//                    Test (4)
						result.Set(3, zero)
						if dif.Get(0) == zero {
							if diftru.Get(0) > abnorm*ulp {
								result.Set(3, ulpinv)
							}
						} else if diftru.Get(0) == zero {
							if dif.Get(0) > abnorm*ulp {
								result.Set(3, ulpinv)
							}
						} else if dif.Get(4) == zero {
							if diftru.Get(4) > abnorm*ulp {
								result.Set(3, ulpinv)
							}
						} else if diftru.Get(4) == zero {
							if dif.Get(4) > abnorm*ulp {
								result.Set(3, ulpinv)
							}
						} else {
							ratio1 = math.Max(math.Abs(diftru.Get(0)/dif.Get(0)), math.Abs(dif.Get(0)/diftru.Get(0)))
							ratio2 = math.Max(math.Abs(diftru.Get(4)/dif.Get(4)), math.Abs(dif.Get(4)/diftru.Get(4)))
							result.Set(3, math.Max(ratio1, ratio2))
						}

						ntestt = ntestt + 4

						//                    Print out tests which fail.
						for j = 1; j <= 4; j++ {
							if (result.Get(j-1) >= thrsh2 && j >= 4) || (result.Get(j-1) >= thresh && j <= 3) {
								t.Fail()
								//                       If this is the first test to fail,
								//                       print a header to the data file.
								if nerrs == 0 {
									fmt.Printf("\n %3s -- Real Expert Eigenvalue/vector problem driver\n", "DXV")

									//                          Print out messages for built-in examples
									//
									//                          Matrix types
									fmt.Printf(" Matrix types: \n\n")
									fmt.Printf(" TYPE 1: Da is diagonal, Db is identity, \n     A = Y^(-H) Da X^(-1), B = Y^(-H) Db X^(-1) \n     YH and X are left and right eigenvectors. \n\n")
									fmt.Printf(" TYPE 2: Da is quasi-diagonal, Db is identity, \n     A = Y^(-H) Da X^(-1), B = Y^(-H) Db X^(-1) \n     YH and X are left and right eigenvectors. \n\n")

									//                          Tests performed
									fmt.Printf("\n Tests performed:  \n     a is alpha, b is beta, l is a left eigenvector, \n     r is a right eigenvector and %s means %s.\n 1 = math.Max | ( b A - a B )%s l | / const.\n 2 = math.Max | ( b A - a B ) r | / const.\n 3 = math.Max ( Sest/Stru, Stru/Sest )  over all eigenvalues\n 4 = math.Max( DIFest/DIFtru, DIFtru/DIFest )  over the 1st and 5th eigenvectors\n\n", "'", "transpose", "'")

								}
								nerrs = nerrs + 1
								if result.Get(j-1) < 10000.0 {
									fmt.Printf(" Type=%2d, IWA=%2d, IWB=%2d, IWX=%2d, IWY=%2d, result %2d is %8.2f\n", iptype, iwa, iwb, iwx, iwy, j, result.Get(j-1))
								} else {
									fmt.Printf(" Type=%2d, IWA=%2d, IWB=%2d, IWX=%2d, IWY=%2d, result %2d is %10.3E\n", iptype, iwa, iwb, iwx, iwy, j, result.Get(j-1))
								}
							}
						}

					label30:
					}
				}
			}
		}
	}

	nlist := []int{4, 4}
	alist := [][]float64{
		{
			8.0000e+00, 4.0000e+00, -1.3000e+01, 4.0000e+00,
			0.0000e+00, 7.0000e+00, -2.4000e+01, -3.0000e+00,
			0.0000e+00, 0.0000e+00, 3.0000e+00, -5.0000e+00,
			0.0000e+00, 0.0000e+00, 0.0000e+00, 1.6000e+01,
		},
		{
			1.0000e+00, 2.0000e+00, 3.0000e+00, 4.0000e+00,
			0.0000e+00, 5.0000e+00, 6.0000e+00, 7.0000e+00,
			0.0000e+00, 0.0000e+00, 8.0000e+00, 9.0000e+00,
			0.0000e+00, 0.0000e+00, 0.0000e+00, 1.0000e+01,
		},
	}
	blist := [][]float64{
		{
			9.0000e+00, -1.0000e+00, 1.0000e+00, -6.0000e+00,
			0.0000e+00, 4.0000e+00, 1.6000e+01, -2.4000e+01,
			0.0000e+00, 0.0000e+00, -1.1000e+01, 6.0000e+00,
			0.0000e+00, 0.0000e+00, 0.0000e+00, 4.0000e+00,
		},
		{
			-1.0000e+00, -1.0000e+00, -1.0000e+00, -1.0000e+00,
			0.0000e+00, -1.0000e+00, -1.0000e+00, -1.0000e+00,
			0.0000e+00, 0.0000e+00, 1.0000e+00, -1.0000e+00,
			0.0000e+00, 0.0000e+00, 0.0000e+00, 1.0000e+00,
		},
	}
	dtrulist := [][]float64{
		{3.1476e+00, 2.5286e+00, 4.2241e+00, 3.4160e+00},
		{1.3639e+00, 4.0417e+00, 6.4089e-01, 6.8030e-01},
	}
	diftrulist := [][]float64{
		{6.7340e-01, 1.1380e+00, 3.5424e+00, 9.5917e-01},
		{7.6064e-01, 8.4964e-01, 1.1222e-01, 1.1499e-01},
	}

	//     Read in data from file to check accuracy of condition estimation
	//     Read input data until n=0
	for _i, n = range nlist {
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				a.Set(i-1, j-1, alist[_i][(i-1)*(n)+j-1])
				b.Set(i-1, j-1, blist[_i][(i-1)*(n)+j-1])
			}
			dtru.Set(i-1, dtrulist[_i][i-1])
			diftru.Set(i-1, diftrulist[_i][i-1])
		}

		nptknt = nptknt + 1

		//     Compute eigenvalues/eigenvectors of (A, B).
		//     Compute eigenvalue/eigenvector condition numbers
		//     using computed eigenvectors.
		golapack.Dlacpy(Full, n, n, a, ai)
		golapack.Dlacpy(Full, n, n, b, bi)

		if ilo, ihi, _, _, linfo, err = golapack.Dggevx('N', 'V', 'V', 'B', n, ai, bi, alphar, alphai, beta, vl, vr, lscale, rscale, s, dif, work, lwork, &iwork, &bwork); linfo != 0 || err != nil {
			t.Fail()
			result.Set(0, ulpinv)
			fmt.Printf(" ddrgvx: %s returned info=%6d.\n         n=%6d, Input example #%2d)\n", "Dggevx", linfo, n, nptknt)
			continue
		}

		//     Compute the norm(A, B)
		golapack.Dlacpy(Full, n, n, ai, work.Matrix(n, opts))
		golapack.Dlacpy(Full, n, n, bi, work.MatrixOff(n*n, n, opts))
		abnorm = golapack.Dlange('F', n, 2*n, work.Matrix(n, opts), work)

		//     Tests (1) and (2)
		result.Set(0, zero)
		dget52(true, n, a, b, vl, alphar, alphai, beta, work, result)
		if result.Get(1) > thresh {
			t.Fail()
			fmt.Printf(" ddrgvx: %s Eigenvectors from %s incorrectly normalized.\n Bits of error=%10.3f,         n=%6d, Input Example #%2d)\n", "Left", "Dggevx", result.Get(1), n, nptknt)
		}

		result.Set(1, zero)
		dget52(false, n, a, b, vr, alphar, alphai, beta, work, result.Off(1))
		if result.Get(2) > thresh {
			t.Fail()
			fmt.Printf(" ddrgvx: %s Eigenvectors from %s incorrectly normalized.\n Bits of error=%10.3f,         n=%6d, Input Example #%2d)\n", "Right", "Dggevx", result.Get(2), n, nptknt)
		}

		//     Test (3)
		result.Set(2, zero)
		for i = 1; i <= n; i++ {
			if s.Get(i-1) == zero {
				if dtru.Get(i-1) > abnorm*ulp {
					result.Set(2, ulpinv)
				}
			} else if dtru.Get(i-1) == zero {
				if s.Get(i-1) > abnorm*ulp {
					result.Set(2, ulpinv)
				}
			} else {
				work.Set(i-1, math.Max(math.Abs(dtru.Get(i-1)/s.Get(i-1)), math.Abs(s.Get(i-1)/dtru.Get(i-1))))
				result.Set(2, math.Max(result.Get(2), work.Get(i-1)))
			}
		}

		//     Test (4)
		result.Set(3, zero)
		if dif.Get(0) == zero {
			if diftru.Get(0) > abnorm*ulp {
				result.Set(3, ulpinv)
			}
		} else if diftru.Get(0) == zero {
			if dif.Get(0) > abnorm*ulp {
				result.Set(3, ulpinv)
			}
		} else if dif.Get(4) == zero {
			if diftru.Get(4) > abnorm*ulp {
				result.Set(3, ulpinv)
			}
		} else if diftru.Get(4) == zero {
			if dif.Get(4) > abnorm*ulp {
				result.Set(3, ulpinv)
			}
		} else {
			ratio1 = math.Max(math.Abs(diftru.Get(0)/dif.Get(0)), math.Abs(dif.Get(0)/diftru.Get(0)))
			ratio2 = math.Max(math.Abs(diftru.Get(4)/dif.Get(4)), math.Abs(dif.Get(4)/diftru.Get(4)))
			result.Set(3, math.Max(ratio1, ratio2))
		}

		ntestt = ntestt + 4

		//     Print out tests which fail.
		for j = 1; j <= 4; j++ {
			if result.Get(j-1) >= thrsh2 {
				t.Fail()
				//           If this is the first test to fail,
				//           print a header to the data file.
				if nerrs == 0 {
					fmt.Printf("\n %3s -- Real Expert Eigenvalue/vector problem driver\n", "DXV")

					//              Print out messages for built-in examples
					//
					//              Matrix types
					fmt.Printf(" Input Example\n")

					//              Tests performed
					fmt.Printf("\n Tests performed:  \n     a is alpha, b is beta, l is a left eigenvector, \n     r is a right eigenvector and %s means %s.\n 1 = math.Max | ( b A - a B )%s l | / const.\n 2 = math.Max | ( b A - a B ) r | / const.\n 3 = math.Max ( Sest/Stru, Stru/Sest )  over all eigenvalues\n 4 = math.Max( DIFest/DIFtru, DIFtru/DIFest )  over the 1st and 5th eigenvectors\n\n", "'", "transpose", "'")

				}
				nerrs = nerrs + 1
				if result.Get(j-1) < 10000.0 {
					fmt.Printf(" Input example #%2d, matrix order=%4d, result %2d is %8.2f\n", nptknt, n, j, result.Get(j-1))
				} else {
					fmt.Printf(" Input example #%2d, matrix order=%4d, result %2d is %10.3E\n", nptknt, n, j, result.Get(j-1))
				}
			}
		}
	}

	//     Summary
	// alasvm("Dxv", nerrs, ntestt, 0)

	work.Set(0, float64(maxwrk))

	return
}
